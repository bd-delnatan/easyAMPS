{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Data",
				"DataFrameModel"
			],
			[
				"Q",
				"QAbstractTableModel"
			],
			[
				"phases",
				"phases_available"
			],
			[
				"Column",
				"ColumnDataSource"
			],
			[
				"linear",
				"linearity_check"
			],
			[
				"pos",
				"postinjection"
			],
			[
				"suff",
				"suffix_pattern"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom AMPS import AMPSexperiment\nfrom pandas import DataFrame\nfrom . import _shglut, _tpflut\n\n\ndef place_in_range(vec, frac):\n    vecmax = vec.max()\n    vecmin = vec.min()\n    return vecmin + (vecmax - vecmin) * frac\n\n\ndef strip_chart(data, grp, ax, column_name=\"TPFratio\"):\n\n    fracs, idx = np.unique(data[\"frac_labeled\"], return_inverse=True)\n    jittered_idx = idx + np.random.random(idx.size) * 0.25\n    xbar = np.arange(fracs.size)\n\n    fraclabels = [f\"{v*100:.1f}%\" for v in fracs]\n\n    ax.bar(\n        xbar,\n        grp[column_name][\"mean\"],\n        yerr=grp[column_name][\"std\"],\n        linewidth=0.8,\n        edgecolor=\"black\",\n        capsize=2.5,\n        color=\"pink\",\n        alpha=0.5,\n        error_kw={\"elinewidth\": 0.75},\n    )\n    ax.plot(jittered_idx, data[column_name], \"r.\", alpha=0.5, ms=8)\n\n    ax.set_xticks(xbar)\n    ax.set_xticklabels(fraclabels)\n    ax.set_xlabel(\"percent labeled\")\n    ax.set_ylabel(f\"{column_name}\")\n\n\ndef linearity_check(grp, ax):\n    # copy the existing axis\n    ax_twin = ax.twinx()\n\n    x = grp.index.values\n    yP = grp[\"P-FLcorr\"][\"mean\"].values\n    yS = grp[\"S-FLcorr\"][\"mean\"].values\n    sy_P = grp[\"P-FLcorr\"][\"std\"].values\n    sy_S = grp[\"S-FLcorr\"][\"std\"].values\n    m1, _, _, _ = np.linalg.lstsq(x[:, np.newaxis], yP, rcond=-1)\n    m2, _, _, _ = np.linalg.lstsq(x[:, np.newaxis], yS, rcond=-1)\n    ax.errorbar(\n        x,\n        yP,\n        yerr=sy_P,\n        fmt=\"o\",\n        mew=0.5,\n        mfc=\"teal\",\n        mec=\"k\",\n        alpha=0.5,\n        ecolor=\"k\",\n        elinewidth=0.75,\n        capsize=2,\n    )\n    ax_twin.errorbar(\n        x,\n        yS,\n        yerr=sy_S,\n        fmt=\"o\",\n        mew=0.5,\n        mfc=\"blue\",\n        mec=\"k\",\n        alpha=0.5,\n        ecolor=\"k\",\n        elinewidth=0.75,\n        capsize=2,\n    )\n\n    # plot linear fits\n    ax.plot(x, m1 * x, \"-\", lw=2, color=\"teal\")\n    ax_twin.plot(x, m2 * x, \"-\", lw=2, color=\"blue\")\n\n    ax.set_ylabel(\"P-FLcorr\", color=\"teal\")\n    ax.tick_params(axis=\"y\", labelcolor=\"teal\")\n    ax_twin.set_ylabel(\"S-FLcorr\", color=\"blue\")\n    ax_twin.tick_params(axis=\"y\", labelcolor=\"blue\")\n\n    ax.grid(False)\n    ax_twin.grid(False)\n\n    ax.set_xlabel(\"fraction labeled\")\n    ax.set_title(\"fluorescence linearity\")\n\n\ndef square_check(grp, ax):\n    # copy the existing axis\n    ax_twin = ax.twinx()\n\n    x = grp.index.values\n    yP = grp[\"P-SHGcorr\"][\"mean\"].values\n    yS = grp[\"S-SHGcorr\"][\"mean\"].values\n    sy_P = grp[\"P-SHGcorr\"][\"std\"].values\n    sy_S = grp[\"S-SHGcorr\"][\"std\"].values\n\n    ax.errorbar(\n        x,\n        yP,\n        yerr=sy_P,\n        fmt=\"o\",\n        mew=0.5,\n        mfc=\"teal\",\n        mec=\"k\",\n        alpha=0.5,\n        ecolor=\"k\",\n        elinewidth=0.75,\n        capsize=2,\n    )\n\n    ax_twin.errorbar(\n        x,\n        yS,\n        yerr=sy_S,\n        fmt=\"o\",\n        mew=0.5,\n        mfc=\"blue\",\n        mec=\"k\",\n        alpha=0.5,\n        ecolor=\"k\",\n        elinewidth=0.75,\n        capsize=2,\n    )\n\n    ax.set_ylabel(\"P-SHGcorr\", color=\"teal\")\n    ax.tick_params(axis=\"y\", labelcolor=\"teal\")\n    ax_twin.set_ylabel(\"S-SHGcorr\", color=\"blue\")\n    ax_twin.tick_params(axis=\"y\", labelcolor=\"blue\")\n\n    ax.grid(False)\n    ax_twin.grid(False)\n\n    ax.set_xlabel(\"fraction labeled\")\n    ax.set_title(\"concentration vs SHG\")\n\n\ndef overview(data, figsize=(8, 6.25), experiment=None):\n    \"\"\" summarize overview of 4-channel data\n\n    This function may change in the future\n\n    Args:\n        data(DataFrame): raw 4-channel data input\n\n    \"\"\"\n    stats = data.groupby(\"frac_labeled\").agg([\"mean\", \"std\"])\n\n    fig, ax = plt.subplots(nrows=2, ncols=2, figsize=figsize)\n\n    ax[0, 0].plot(\n        data[\"P-FLcorr\"].values.ravel(), data[\"P-SHG\"].values.ravel(), \"r.\", alpha=0.3,\n    )\n    ax[0, 1].plot(\n        data[\"S-FLcorr\"].values.ravel(), data[\"S-SHG\"].values.ravel(), \"r.\", alpha=0.3,\n    )\n\n    ax[0, 0].errorbar(\n        stats[\"P-FLcorr\"][\"mean\"],\n        stats[\"P-SHG\"][\"mean\"],\n        xerr=stats[\"P-FLcorr\"][\"std\"],\n        yerr=stats[\"P-SHG\"][\"std\"],\n        fmt=\"o\",\n        mfc=\"red\",\n        mec=\"black\",\n        mew=0.5,\n        ecolor=\"red\",\n        elinewidth=0.75,\n        capsize=2.0,\n    )\n\n    ax[0, 1].errorbar(\n        stats[\"S-FLcorr\"][\"mean\"],\n        stats[\"S-SHG\"][\"mean\"],\n        xerr=stats[\"S-FLcorr\"][\"std\"],\n        yerr=stats[\"S-SHG\"][\"std\"],\n        fmt=\"o\",\n        mfc=\"red\",\n        mec=\"black\",\n        mew=0.5,\n        ecolor=\"red\",\n        elinewidth=0.75,\n        capsize=2.0,\n    )\n\n    if experiment is not None:\n        # overlay the fit result\n        if experiment.Pphases.optres.success:\n            ax[0, 0].plot(\n                experiment.Pphases.fit.x,\n                experiment.Pphases.fit.y,\n                \"-\",\n                c=\"darkred\",\n                lw=1.5,\n                zorder=-100,\n            )\n\n        if experiment.Sphases.optres.success:\n            ax[0, 1].plot(\n                experiment.Sphases.fit.x,\n                experiment.Sphases.fit.y,\n                \"-\",\n                c=\"darkred\",\n                lw=1.5,\n                zorder=-100,\n            )\n\n    ax[0, 0].set_xlabel(\"P-FLcorr\")\n    ax[0, 0].set_ylabel(\"P-SHG\")\n\n    ax[0, 1].set_xlabel(\"S-FLcorr\")\n    ax[0, 1].set_ylabel(\"S-SHG\")\n\n    strip_chart(data, stats, ax[1, 0])\n    ax[1, 0].tick_params(axis=\"x\", which=\"major\", labelsize=10)\n\n    linearity_check(stats, ax[1, 1])\n    fig.tight_layout()\n    return fig, ax\n\n\ndef overview2(experiment, figsize=(8, 9.4)):\n    \"\"\" summarize overview of 4-channel data\n\n    This function will plot an analyzed AMPS experiment object.\n    It assumes all of the quantities are already present in data.\n\n    Args:\n        data(DataFrame): raw 4-channel data input\n\n    \"\"\"\n    stats = experiment.grpdf\n    data = experiment.data\n\n    fig, ax = plt.subplots(nrows=3, ncols=2, figsize=figsize)\n\n    ax[0, 0].plot(\n        data[\"P-FLcorr\"].values.ravel(), data[\"P-SHG\"].values.ravel(), \"r.\", alpha=0.3,\n    )\n    ax[0, 1].plot(\n        data[\"S-FLcorr\"].values.ravel(), data[\"S-SHG\"].values.ravel(), \"r.\", alpha=0.3,\n    )\n\n    ax[0, 0].errorbar(\n        stats[\"P-FLcorr\"][\"mean\"],\n        stats[\"P-SHG\"][\"mean\"],\n        xerr=stats[\"P-FLcorr\"][\"std\"],\n        yerr=stats[\"P-SHG\"][\"std\"],\n        fmt=\"o\",\n        mfc=\"red\",\n        mec=\"black\",\n        mew=0.5,\n        ecolor=\"red\",\n        elinewidth=0.75,\n        capsize=2.0,\n    )\n\n    ax[0, 1].errorbar(\n        stats[\"S-FLcorr\"][\"mean\"],\n        stats[\"S-SHG\"][\"mean\"],\n        xerr=stats[\"S-FLcorr\"][\"std\"],\n        yerr=stats[\"S-SHG\"][\"std\"],\n        fmt=\"o\",\n        mfc=\"red\",\n        mec=\"black\",\n        mew=0.5,\n        ecolor=\"red\",\n        elinewidth=0.75,\n        capsize=2.0,\n    )\n\n    if experiment is not None:\n\n        if experiment.Pphases is None:\n            pass\n        # overlay the fit result\n        elif experiment.Pphases.optres.success:\n            ax[0, 0].plot(\n                experiment.Pphases.fit.x,\n                experiment.Pphases.fit.y,\n                \"-\",\n                c=\"darkred\",\n                lw=1.5,\n                zorder=-100,\n            )\n\n            # figure out position for text\n            xpos = place_in_range(experiment.Pphases.fit.x, 0.1)\n            ypos = place_in_range(experiment.Pphases.fit.y, 0.8)\n\n            # convert to degrees\n            _deg = np.rad2deg(experiment.Pphases.optres.params[\"delphi\"].value)\n\n            if experiment.Pphases.optres.params[\"delphi\"].stderr is not None:\n                _degerr = np.rad2deg(experiment.Pphases.optres.params[\"delphi\"].stderr)\n            else:\n                _degerr = np.nan\n\n            ax[0, 0].text(\n                xpos, ypos, f\"{_deg:.0f} ± {_degerr:.0f} ˚\", fontsize=12,\n            )\n\n        if experiment.Sphases is None:\n            pass\n        elif experiment.Sphases.optres.success:\n            ax[0, 1].plot(\n                experiment.Sphases.fit.x,\n                experiment.Sphases.fit.y,\n                \"-\",\n                c=\"darkred\",\n                lw=1.5,\n                zorder=-100,\n            )\n            # figure out position for text\n            xpos = place_in_range(experiment.Sphases.fit.x, 0.1)\n            ypos = place_in_range(experiment.Sphases.fit.y, 0.8)\n\n            # convert to degrees\n            _deg = np.rad2deg(experiment.Sphases.optres.params[\"delphi\"].value)\n            _degerr = np.rad2deg(experiment.Sphases.optres.params[\"delphi\"].stderr)\n\n            ax[0, 1].text(\n                xpos, ypos, f\"{_deg:.0f} ± {_degerr:.0f} ˚\", fontsize=12,\n            )\n\n    ax[0, 0].set_xlabel(\"P-FLcorr\")\n    ax[0, 0].set_ylabel(\"P-SHG\")\n\n    ax[0, 1].set_xlabel(\"S-FLcorr\")\n    ax[0, 1].set_ylabel(\"S-SHG\")\n\n    strip_chart(data, stats, ax[1, 0])\n    ax[1, 0].tick_params(axis=\"x\", which=\"major\", labelsize=11)\n\n    linearity_check(stats, ax[1, 1])\n\n    strip_chart(data, stats, ax[2, 0], column_name=\"SHGratio\")\n    ax[2, 0].tick_params(axis=\"x\", which=\"major\", labelsize=11)\n\n    if (\"angle\" in data.columns) and (\"distribution\" in data.columns):\n\n        labeled = data.query(\"frac_labeled == 1.0\")\n        rest = data.query(\"frac_labeled != 1.0\")\n\n        ax[2, 1].plot(rest[\"distribution\"].values, rest[\"angle\"].values, \"o\", c=\"gray\")\n        ax[2, 1].plot(\n            labeled[\"distribution\"].values, labeled[\"angle\"].values, \"o\", c=\"darkred\",\n        )\n\n        ax[2, 1].set_xlabel(\"distribution\")\n        ax[2, 1].set_ylabel(\"angle\")\n        ax[2, 1].set_xlim([2.0, 70.0])\n        ax[2, 1].set_ylim([0.0, 90.0])\n\n    else:\n        ax[2, 1].axis(\"off\")\n\n    fig.tight_layout()\n    return fig, ax\n\n\ndef compare_column(\n    experiment_dict,\n    column_name,\n    ax=None,\n    frac_labeled=1.0,\n    barwidth=0.8,\n    barcolor=\"pink\",\n    markercolor=\"red\",\n    xtick_kwargs={},\n):\n    \"\"\" Generate bar plot for each column for each experiment \"\"\"\n    xlabels = []\n    heights = []\n    heights_err = []\n    rawdata = []\n    idxlist = []\n\n    for i, (name, expt) in enumerate(experiment_dict.items()):\n\n        if isinstance(expt, AMPSexperiment):\n            data = expt.data\n        elif isinstance(expt, DataFrame):\n            data = expt\n\n        xlabel = name\n        grp = data.groupby(\"frac_labeled\").agg([\"mean\", \"std\"])\n        xlabels.append(xlabel)\n        heights.append(grp.loc[frac_labeled][column_name][\"mean\"])\n        heights_err.append(grp.loc[frac_labeled][column_name][\"std\"])\n        _data = data[data[\"frac_labeled\"] == frac_labeled][column_name].values\n        # build raw data points in a list\n        rawdata.append(_data)\n        idxlist.append(np.repeat(i, _data.size))\n\n    rawarr = np.concatenate(rawdata)\n    idxarr = np.concatenate(idxlist)\n\n    if ax is None:\n        returnfig = True\n        fig, ax = plt.subplots()\n    else:\n        returnfig = False\n\n    xpos = np.arange(len(xlabels))\n    jittered_idx = idxarr + (np.random.random(idxarr.size) - 0.5) * barwidth / 2.5\n    ax.bar(\n        xpos,\n        heights,\n        yerr=heights_err,\n        width=barwidth,\n        linewidth=0.8,\n        capsize=2.5,\n        edgecolor=\"black\",\n        color=barcolor,\n        alpha=0.7,\n        error_kw={\"elinewidth\": 0.8},\n    )\n\n    ax.set_xticks(xpos)\n    ax.set_xticklabels(xlabels, **xtick_kwargs)\n\n    ax.plot(jittered_idx, rawarr, \"o\", c=markercolor, alpha=0.5, ms=8)\n    ax.set_title(f\"{column_name}\")\n    ax.set_ylabel(f\"{column_name}\")\n\n    if returnfig:\n        return fig, ax\n\n\ndef compare_pair(experiment_dict, column1, column2, ax=None, frac_labeled=1.0):\n    \"\"\" scatter plot between columns of experiments \"\"\"\n\n    if ax is None:\n        fig, ax = plt.subplots()\n        return_objs = True\n    else:\n        return_objs = False\n\n    for i, (name, expt) in enumerate(experiment_dict.items()):\n\n        if isinstance(expt, AMPSexperiment):\n            data = expt.data\n        elif isinstance(expt, DataFrame):\n            data = expt\n\n        subdata = data[data[\"frac_labeled\"] == frac_labeled]\n\n        (p,) = ax.plot(subdata[column1], subdata[column2], \"o\", alpha=0.7, label=name)\n\n    ax.set_xlabel(f\"{column1}\")\n    ax.set_ylabel(f\"{column2}\")\n    ax.legend()\n\n    if return_objs:\n        return fig, ax\n\n\ndef compare_quadratic_fit(experiment_dict, size=(11, 5)):\n    fig, ax = plt.subplots(ncols=2, figsize=size)\n\n    for name, expt in experiment_dict.items():\n        (p1,) = ax[0].plot(expt.x_P, expt.y_P, \".\", alpha=0.5)\n        ax[0].errorbar(\n            expt.mean_x_P,\n            expt.mean_y_P,\n            xerr=expt.std_x_P,\n            yerr=expt.std_y_P,\n            fmt=\"o\",\n            color=p1.get_color(),\n            ecolor=p1.get_color(),\n            elinewidth=1.5,\n            capsize=2.5,\n            label=name,\n        )\n\n        if expt.Pphases is not None:\n            ax[0].plot(\n                expt.Pphases.fit.x, expt.Pphases.fit.y, \"-\", lw=2, c=p1.get_color(),\n            )\n\n        (p2,) = ax[1].plot(expt.x_S, expt.y_S, \".\", alpha=0.5)\n        ax[1].errorbar(\n            expt.mean_x_S,\n            expt.mean_y_S,\n            xerr=expt.std_x_S,\n            yerr=expt.std_y_S,\n            fmt=\"o\",\n            color=p2.get_color(),\n            ecolor=p2.get_color(),\n            elinewidth=1.5,\n            capsize=2.5,\n            label=name,\n        )\n\n        if expt.Sphases is not None:\n            ax[1].plot(\n                expt.Sphases.fit.x, expt.Sphases.fit.y, \"-\", lw=2, c=p2.get_color(),\n            )\n\n    ax[0].set_xlabel(\"P-FLcorr\")\n    ax[0].set_ylabel(\"P-SHG\")\n    ax[1].set_xlabel(\"S-FLcorr\")\n    ax[1].set_ylabel(\"S-SHG\")\n    ax[0].legend()\n    ax[1].legend()\n    fig.tight_layout()\n\n    return fig, ax\n\n\ndef visualize_AMPS_solution(\n    rshg=None, rtpf=None, ax=None, shg_color=\"darkblue\", tpf_color=\"green\"\n):\n\n    from matplotlib.lines import Line2D\n\n    if ax is None:\n        returnfig = True\n        fig, ax = plt.subplots()\n\n    distributions = _shglut[\"distributions\"]\n    angles = _shglut[\"angles\"]\n    shgratio = _shglut[\"map\"]\n    tpfratio = _tpflut[\"map\"]\n\n    ax.contour(\n        distributions,\n        angles,\n        shgratio,\n        levels=[rshg],\n        colors=[shg_color],\n        linewidths=[2.0],\n    )\n    ax.contour(\n        distributions,\n        angles,\n        tpfratio,\n        levels=[rtpf],\n        colors=[tpf_color],\n        linewidths=[2.0],\n    )\n\n    custom_lines = [\n        Line2D([0], [0], color=shg_color, lw=2),\n        Line2D([0], [0], color=tpf_color, lw=2),\n    ]\n    ax.set_xlabel(\"distribution\")\n    ax.set_ylabel(\"angle\")\n    ax.legend(custom_lines, [\"SHG\", \"TPF\"], loc=\"lower right\")\n\n    if returnfig:\n        return fig, ax\n",
			"file": "/C/Users/delna/Apps/Python/AMPS/viz.py",
			"file_size": 15570,
			"file_write_time": 132319608183721145,
			"settings":
			{
				"buffer_size": 14578,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"theme",
				"UI: Select Theme"
			],
			[
				"color",
				"UI: Select Color Scheme"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"unicode",
				"Unicode Completion: Toggle"
			],
			[
				"ayu",
				"ayu: Activate theme"
			],
			[
				"ermove",
				"Package Control: Remove Package"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"uninstall",
				"Colorsublime: Uninstall Theme"
			],
			[
				"ui",
				"UI: Select Theme"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 172.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Users/delna/Apps/Python"
	],
	"file_history":
	[
		"/C/Users/delna/Apps/Julia/AMPS/AMPS.jl",
		"/C/Users/delna/Apps/Julia/AMPS.jl",
		"/C/Users/delna/AppData/Roaming/Sublime Text 3/Packages/Default/Preferences.sublime-settings",
		"/C/Users/delna/.julia/config/startup.jl",
		"/C/Users/delna/AppData/Roaming/Sublime Text 3/Packages/Alignment/Base File.sublime-settings",
		"/C/Users/delna/Apps/easyAMPS/readme.md",
		"/D/using_git.txt",
		"/C/Users/delna/Apps/Python/compiled_amps.py",
		"/C/Users/delna/miniconda3/envs/tf-gpu/Library/qml/QtDataVisualization/designer/Scatter3DSpecifics.qml",
		"/C/Users/delna/Apps/Python/theano_amps.py",
		"/C/Users/delna/.julia/prefs/IJulia",
		"/C/Users/delna/Apps/Python/bayesian_amps.py",
		"/C/Users/delna/miniconda3/Lib/site-packages/matplotlib/mpl-data/stylelib/bmh.mplstyle",
		"/C/Users/delna/Apps/Python/numdiffpy.py",
		"/C/Users/delna/JupyterNotebooks/Bayesian_AMPS/pymc3_numerical_integration.py",
		"/C/Users/delna/Data/run_inference_01.py",
		"/C/Users/delna/Apps/Python/AMPS/visualization.py",
		"/C/Users/delna/Downloads/continuous-6.py",
		"/C/Users/delna/.jupyter/nbconfig/notebook.json",
		"/C/Users/delna/Apps/Python/AMPS/__init__.py",
		"/C/Users/delna/Apps/Python/PyBiodesy/Visualization.py",
		"/C/Users/delna/Data/DE_p38_Mal1_tPyMPO.yaml",
		"/C/Users/delna/Apps/bin/generate_plots.py",
		"/C/Users/delna/Apps/bin/parse_AMPS.py",
		"/C/Users/delna/Data/DE_p38_Mal2.yaml",
		"/C/Users/delna/Apps/Python/bokeh_utils.py",
		"/C/Users/delna/Apps/Python/preAMPS.py",
		"/C/Users/delna/Apps/Python/PyBiodesy/DataStructures.py",
		"/C/Users/delna/Apps/Python/PyBiodesy/Fitting.py",
		"/C/Users/delna/Desktop/ucsf_income_2019.txt",
		"/C/Users/delna/Apps/Python/prepare_AMPS.py",
		"/C/Users/delna/Experiments/config_02_p38.yaml",
		"/C/Users/delna/Experiments/config_10_p38.yaml",
		"/C/Users/delna/Experiments/config_16_dhfr.yaml",
		"/C/Users/delna/Experiments/generate_plots.py",
		"/C/Users/delna/Experiments/AMPS_validation/17_DHFR_Q65C_T73C_K76C_N23C/Analysis/pxl3nan_ratio_data_true-bg-counts-angle.py",
		"/C/Users/delna/Experiments/config_17_dhfr.yaml",
		"/C/Users/delna/Experiments/config_18_dhfr.yaml",
		"/C/Users/delna/Apps/Python/NoExcel_dev.py",
		"/C/Users/delna/Experiments/prepare_AMPS.py",
		"/C/Users/delna/Experiments/run_program.py",
		"/C/Users/delna/Apps/Python/AMPSsolution.py",
		"/C/Users/delna/Experiments/config_preinj.yaml",
		"/C/Users/delna/Apps/Python/NotebookSnippets.py",
		"/C/Users/delna/Downloads/cudnn-10.2-windows10-x64-v7.6.5.32/cuda/include/cudnn.h",
		"/C/Users/delna/Apps/test01.py",
		"/C/Users/delna/Apps/Python/PyBiodesy/integrals.py",
		"/C/Users/delna/Apps/Fortran/ForPython/amps.f90",
		"/C/Users/delna/Apps/Fortran/ForPython/libintegrand.f90",
		"/C/Users/delna/Apps/bin/numpy_benchmark.py",
		"/C/Users/delna/.condarc",
		"/C/Users/delna/Desktop/libgpuarray_notes.txt",
		"/C/Users/delna/miniconda3/Lib/site-packages/theano/__init__.py",
		"/C/Users/delna/Apps/bin/watch.bat",
		"/C/Users/delna/buildir/libgpuarray/Build/cmake_install.cmake",
		"/C/Users/delna/buildir/libgpuarray/Build/src/cmake_install.cmake",
		"/C/Users/delna/buildir/libgpuarray/Build/src/CTestTestfile.cmake",
		"/C/Users/delna/miniconda3/Lib/site-packages/DE_custom_path.pth",
		"/C/Users/delna/Apps/libgpuarray/include/gpuarray/ext_cuda.h",
		"/C/Users/delna/.theanorc",
		"/C/Users/delna/.jupyter/jupyter_qtconsole_config.py",
		"/C/Users/delna/JupyterNotebooks/Prototypes/pymc3_numerical_integration.py",
		"/C/Users/delna/Apps/Fortran/ForPython/compile_all.sh",
		"/C/Users/delna/Miniconda3/Lib/site-packages/DE_custom_path.pth",
		"/C/Users/delna/Documents/The Witcher 3/user.settings",
		"/C/Users/delna/Miniconda3/Lib/site-packages/notebook/static/custom/custom.css",
		"/C/Users/delna/AppData/Roaming/Sublime Text 3/Packages/sublack/sublack.sublime-settings",
		"/C/Users/delna/AppData/Roaming/Sublime Text 3/Packages/User/conda-base-Python3.sublime-build",
		"/C/Users/delna/JupyterNotebooks/f2py_tests/miniconda-base-Python3.sublime-build"
	],
	"find":
	{
		"height": 40.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/C/Users/delna/Apps/Python/AMPS/viz.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14578,
						"regions":
						{
						},
						"selection":
						[
							[
								13400,
								13400
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6741.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 226.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "Packages/User/conda-base-Python3.sublime-build",
	"project": "BiodesyTools.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": false,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 235.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
